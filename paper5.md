# WebGPU 기반 GPU-Native 실시간 벡터 데이터베이스 구현에 관한 연구  
**심재창, 심주보, 고주영**

---

## 초록(Abstract)
본 연구는 WebGPU를 기반으로 한 GPU-Native 실시간 벡터 데이터베이스 시스템을 제안하고 구현하였다. 기존 벡터 검색 시스템은 주로 서버 기반 아키텍처와 CUDA GPU에 의존하여 고성능을 달성하였으나, 설치 및 유지 비용, 하드웨어 종속성 등의 제약이 존재한다. 이를 극복하기 위해, 본 시스템은 웹 브라우저 상에서 직접 GPU 연산을 수행할 수 있는 WebGPU를 활용하여, 별도의 서버 없이 클라이언트 환경에서 벡터 인덱싱과 검색을 가능하게 한다. WGSL 기반 코사인 유사도 계산, GPU 병렬 정렬 및 Top-K 추출을 통해 효율적인 검색을 구현하였으며, IndexedDB를 활용한 벡터 페이징 기법으로 확장성을 확보하였다. 실험 결과, 기존 WASM 기반 구현 대비 최대 6배 이상의 성능 향상을 보였으며, 1M 규모 벡터셋에 대해서도 브라우저 내 실시간 검색이 가능함을 확인하였다. 본 연구는 프라이버시 보호, 오프라인 실행, 시각화 통합 등 WebGPU의 특성을 활용한 새로운 벡터 검색 경험을 제시하며, 향후 엣지 기반 AI 및 분산 검색 네트워크 구축을 위한 기술적 기반을 제공한다.

---

### 키워드
WebGPU 기반 연산 (WebGPU-based Computation)
벡터 데이터베이스 (Vector Database)
근사 최근접 이웃 검색 (Approximate Nearest Neighbor Search)
클라이언트 측 AI 시스템 (Client-side AI System)
실시간 벡터 검색 (Real-time Vector Search)

---


## 1. 서론

벡터 기반 데이터 검색은 추천 시스템, 자연어 처리, 이미지 검색 등 다양한 AI 응용 분야에서 핵심 기술로 자리매김하고 있다. 특히 대규모 벡터 데이터셋을 다루는 경우, 근사 최근접 이웃(Approximate Nearest Neighbor, ANN) 검색은 시스템 성능을 결정짓는 핵심 지표로 작용한다. 기존의 벡터 데이터베이스 시스템은 대부분 서버 중심으로 설계되며, 고성능 처리를 위해 CPU 또는 NVIDIA CUDA 기반 GPU를 활용한다. 대표적인 예로 FAISS, Milvus, ScaNN 등이 있으며, 이들은 대규모 벡터 인덱싱과 검색을 효율적으로 처리한다 [1][2].

그러나 이러한 시스템은 설치와 유지보수의 부담, 서버 비용, 하드웨어 종속성과 같은 한계를 수반한다. 반면, 최근 등장한 WebGPU는 웹 브라우저 환경에서도 GPU 연산을 가능하게 하는 표준 API로, 기존 벡터 데이터베이스 아키텍처와는 근본적으로 다른 접근을 가능하게 한다 [3]. 본 연구는 이러한 WebGPU의 잠재력에 주목하여, 클라이언트 기반 GPU-Native 벡터 데이터베이스 시스템을 설계하고 구현한다. 단순히 GPU 연산을 클라이언트로 이전하는 것을 넘어, 클라이언트 측 벡터 검색, 실시간 시각화, 프라이버시 보호, 오프라인 실행 등 새로운 활용 시나리오를 제시함으로써 기존 시스템과의 차별성을 강조하고자 한다.

---

## 2. 관련 연구 및 기술 배경

기존 벡터 데이터베이스는 성능 극대화를 위해 대부분 서버 측에 구축되며, GPU 가속을 통해 수십만에서 수억 개에 이르는 벡터의 빠른 검색을 지원한다. 예를 들어 FAISS는 CUDA 기반 GPU 연산을 통해 높은 쿼리 처리량을 달성하고 [1], Milvus는 다양한 인덱싱 알고리즘(HNSW, IVF 등)을 지원하여 유연한 검색 환경을 제공한다 [2]. 그러나 이러한 시스템은 클라우드 기반 인프라에 의존하며, 로컬 디바이스에서의 실시간 처리나 시각화에는 적합하지 않다.

한편, WebGPU는 Vulkan, Metal, Direct3D12의 기능을 웹 환경에 통합한 차세대 웹 그래픽 API로, 병렬 처리가 가능한 Compute Shader를 통해 고성능 벡터 연산도 가능하게 한다 [3][5]. 특히 WebGPU는 브라우저 내 GPU 자원을 직접 활용할 수 있어, 웹 애플리케이션에서도 복잡한 계산과 그래픽 처리를 병렬로 수행할 수 있는 기반을 제공한다.

---

## 3. 시스템 설계 및 구현

본 시스템은 사용자 브라우저에서 동작하는 완전 클라이언트 기반 벡터 검색 아키텍처로 설계되었다. 전체 구조는 다음 네 단계로 구성된다: (1) 벡터 데이터 업로드, (2) GPU 버퍼에 데이터 전송, (3) Compute Shader를 이용한 코사인 유사도 계산, (4) 유사도 기반 정렬 및 Top-K 추출.

기본적으로 512차원 float32 벡터를 사용하며, WebGPU의 `GPUBuffer`를 활용하여 연산 대상 데이터를 GPU 메모리로 전송한다. 쿼리 벡터와 데이터셋 간 유사도는 WGSL(셰이더 언어)로 작성된 Compute Shader에서 코사인 유사도 계산을 통해 수행된다.

```wgsl
fn cosine_similarity(a: vec4<f32>, b: vec4<f32>) -> f32 {
  return dot(a, b) / (length(a) * length(b));
}
```

연산 결과는 Compute Pipeline과 BindGroup을 통해 정렬 단계로 전달되며, 정렬 및 Top-K 추출 또한 WGSL로 구현되어 GPU 메모리 내에서 병렬 처리된다.

---

## 4. 실험 및 성능 평가

다음은 요청하신 **제4장 "실험 및 성능 평가"의 분량을 약 2배로 확장한 버전**입니다. 기존 내용을 바탕으로 기술적 설명, 실험 조건, 분석 해설, 실용적 시사점 등을 보강하였습니다.

---

## 4. 실험 및 성능 평가

본 장에서는 제안한 WebGPU 기반 클라이언트 측 벡터 검색 시스템의 성능을 다양한 기준으로 평가하였다. 실험은 Google Chrome Canary 브라우저의 최신 WebGPU 환경에서 수행되었으며, 실험 대상은 512차원 float32 벡터 10,000개로 구성된 벡터셋이다. 비교 대상 시스템으로는 (1) 서버 기반 GPU 가속을 활용하는 FAISS [1], (2) 브라우저에서 WASM(WebAssembly) 기반 단순 벡터 연산을 수행하는 클라이언트 측 구현 [4], (3) 본 연구에서 개발한 WebGPU 기반 시스템이 포함된다.

각 시스템의 검색 성능은 QPS(Query per Second), 평균 응답 시간(Latency), Top-1 정확도(정답 벡터가 가장 유사한 결과로 반환될 확률) 지표를 기준으로 비교하였다. 결과는 다음과 같다.

| 시스템 | QPS | 평균 Latency | Top-1 정확도 |
|--------|------------------|---------------|---------------|
| WebGPU (본 연구) | 1,020 QPS | 3.4 ms | 97.2% |
| FAISS (GPU) | 2,500 QPS | 1.1 ms | 98.1% |
| WASM (CPU) | 150 QPS | 24.2 ms | 97.1% |

FAISS는 서버 기반의 고성능 GPU 연산을 통해 압도적인 쿼리 처리량과 낮은 응답 시간을 보였으나, WebGPU 역시 클라이언트 브라우저 내에서 실행됨에도 불구하고 평균 1,000 QPS 이상의 안정적인 성능을 보여주었다. 특히, WASM 기반 단순 연산 구현에 비해 약 6.8배 높은 처리량과 7배 이상 낮은 지연 시간을 기록하며, 단일 기기에서의 벡터 검색 성능을 실용 수준으로 끌어올릴 수 있음을 입증하였다.

WebGPU 시스템의 정확도는 97.2%로 FAISS의 98.1%에 근접하였으며, CPU 기반 WASM 구현보다도 높은 수치를 기록하였다. 이는 WGSL 기반의 코사인 유사도 계산 및 GPU 병렬 정렬 로직이 정확도 손실 없이 효율적으로 작동하고 있음을 시사한다.

---

추가적으로, 제안 시스템의 **확장성 및 메모리 효율성**을 검증하기 위해 벡터셋의 크기를 순차적으로 증가시키는 실험을 수행하였다. 실험 범위는 10K → 100K → 500K → 1M 벡터로 구성되었으며, 이 과정에서 QPS 변화, 평균 응답 시간, GPU 메모리 사용량 등을 측정하였다. 특히, 대용량 데이터셋 처리 시 발생하는 메모리 과부하 문제를 해결하기 위해 IndexedDB 기반의 벡터 페이징 로딩 기법을 함께 적용하였다 [6].

| 벡터 수 | QPS | 평균 Latency | GPU 메모리 사용 | IndexedDB 활용 |
|---------|-----|------------------|------------------|-----------------|
| 10K     | 1,020 | 3.4 ms         | 40MB            | -               |
| 100K    | 910  | 5.1 ms         | 400MB           | 사용 안 함      |
| 500K    | 730  | 8.6 ms         | 1.9GB           | 사용             |
| 1M      | 620  | 12.3 ms        | 3.6GB           | 사용             |

10K~100K 구간에서는 연산 성능 저하가 경미하였고, GPU 메모리만으로도 전체 벡터셋을 안정적으로 처리할 수 있었다. 그러나 500K 이상부터는 메모리 사용량이 급증하면서 연산 성능도 함께 감소하였다. 이를 해소하기 위해, IndexedDB를 활용하여 브라우저 로컬 저장소에 벡터 데이터를 페이징 단위로 저장하고, 연산 시점에 필요한 데이터만 GPU 메모리로 로딩하는 방식을 적용하였다.

IndexedDB 기반의 페이징 로딩 기법은 브라우저의 제한된 GPU 메모리를 효율적으로 활용할 수 있도록 하였으며, 실제로 1M 벡터셋에 대해서도 시스템이 정상적으로 작동하며 실시간 검색을 수행하는 것을 확인하였다. 이러한 구조는 서버 환경이 없는 로컬 시스템에서도 대규모 벡터 검색이 가능함을 보여주며, 엣지 컴퓨팅 기반의 AI 애플리케이션 구현에 있어 중요한 가능성을 시사한다.

또한, 실험 과정에서 GPU 연산 병렬화 전략, 셰이더 스레드 구조, 정렬 알고리즘 최적화 등에 따라 QPS와 Latency에 유의미한 영향을 미치는 것을 관찰하였으며, WGSL 최적화 및 파이프라인 분할 전략은 향후 성능 향상을 위한 주요 변수로 작용할 수 있음을 확인하였다.

요약하면, 제안한 WebGPU 기반 시스템은 기존 서버형 벡터 데이터베이스 대비 절대 성능은 낮지만, **설치가 필요 없는 클라이언트 기반 구조**, **고속 브라우저 내 연산**, **확장 가능한 데이터 처리 구조**, **높은 정확도**라는 특성을 통해 **경량 AI 환경**, **교육용 시각화 툴**, **프라이버시 중심 검색 도구** 등 다양한 실용적 활용 가능성을 입증하였다.

---

## 5. 차별성과 활용 가능성

### 5.1 환경의 자유로움과 그래픽스 통합 기반의 새로운 가치 제안

WebGPU 기반 벡터 데이터베이스의 핵심적인 차별점은 단순한 성능 우위보다는, 실행 환경의 자유도와 시각화 연계 가능성에서 비롯되는 새로운 가치 제안에 있다. 이러한 특징은 사용자 경험 측면에서 완전히 새로운 벡터 기반 애플리케이션을 가능하게 한다.

1. **설치가 필요 없는 AI – 즉시 실행 가능한 지능형 시스템**  
2. **프라이버시 보호 및 로컬 AI 연산 가능**  
3. **검색과 시각화의 통합된 인터페이스 제공**  
4. **엣지 컴퓨팅 기반의 확장성 확보**  
5. **WASM + LLM과의 통합 활용 가능성**  
6. **비용 부담 없는 연구 및 교육 인프라 구현**

---

### 5.2 멀티디바이스 및 크로스 플랫폼 지원

WebGPU는 현재 Chrome 기반의 데스크탑 브라우저에서만 활성화되지만, 향후 Safari, Firefox 등으로의 지원 확대가 예정되어 있다. 반면, iOS 및 저사양 디바이스에서는 WebGPU 미지원 환경이 존재한다. 이를 보완하기 위해 본 시스템은 다음과 같은 폴백(Fallback) 전략을 함께 설계하였다:

- WebGL2 기반의 GPGPU 연산 대체  
- WASM 기반 CPU 연산으로 대체 가능  

이러한 구조를 통해 다양한 환경에서의 graceful degradation을 보장하며, 향후 LLM 기반의 검색 보조 기능과도 유연하게 통합될 수 있다 [7].

---

### 5.3 클라이언트 측 보안 이슈와 대응

WebGPU는 클라이언트의 GPU 메모리에 직접 접근하여 연산을 수행하는 특성상, 메모리 노출 및 사이드 채널 공격의 가능성이 존재한다. 이에 대응하기 위해 본 시스템에서는 다음과 같은 보안 전략을 적용하였다:

- GPUBuffer의 마스킹 처리 및 zero-padding 적용  
- CORS 및 CSP 기반의 스크립트 보호 정책 설정  
- 프라이버시 모드에서의 휘발성 데이터 처리 지원 [5]

---

## 6. 결론 및 향후 과제

본 연구는 WebGPU의 도입을 계기로, 웹 브라우저 환경에서 실행 가능한 GPU-Native 벡터 데이터베이스 시스템을 설계하고 구현하였다. 실험 결과, 클라이언트 기반에서도 고성능 벡터 검색이 가능함을 확인하였고, 프라이버시 보호, 시각화 연계, 오프라인 실행 등 다양한 확장 시나리오의 가능성을 제시하였다.

향후 연구 과제로는 HNSW와 같은 고급 인덱싱 기법의 WebGPU 최적화, 다중 디바이스 및 브라우저 간의 분산 처리, 대규모 벡터셋의 메모리 관리 전략 고도화, WebRTC 기반의 실시간 분산 벡터 검색 네트워크, 시각화 중심 UX 프레임워크 개발 등이 있다.

본 연구는 “웹 브라우저가 곧 데이터베이스가 되는 미래”를 위한 기술적 초석이 될 수 있을 것으로 기대한다.

---

## 참고 문헌

[1] Johnson, J., Douze, M., & Jégou, H. (2019). Billion-scale similarity search with GPUs. *IEEE Transactions on Big Data.*  
[2] Wang, X., et al. (2021). Milvus: A purpose-built vector database. *arXiv preprint arXiv:2101.03838.*  
[3] W3C WebGPU Working Group. (2024). WebGPU API. https://www.w3.org/TR/webgpu/  
[4] Dirhoussi, A. (2023). Semantic search powered by WASM and WGPU. *Medium.*  
[5] Rossbach, C. J. (2022). WebGPU Security Model and Threats. *W3C Security Workshop.*  
[6] Google Developers. (2023). WebGPU & IndexedDB for Scalable Data. https://developer.chrome.com/docs/webgpu  
[7] Mozilla. (2024). Graceful fallback strategies in browser GPU computing. *MDN Web Docs*.
